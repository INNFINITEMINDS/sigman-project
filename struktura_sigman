Legenda:
> sample_rate               - obiekt/zmienna
= value_at(<float> time)    - funkcja
<float>                     - rodzaj danych
[<float> begin_time]        - opcjonalne argumenty do funkcji

sigman/__init__.py
    Data_line - wycinek danych ciągłych
        > <string> line_type - rodzaj wykresu ('ecg','bp',itp.)
        > <float> sample_length - czas między punktami w czasie
        > <float> complete_length - całkowity czas wycinka
        > <float> offset - poprawka czasowa względem pozostałych wykresów danych
        > <numpy.array> data - tablica zawierająca wszystkie wartości y
        = value_at(<float> time) - zwraca wartość y w danym czasie; jeśli podana wartość jest pomiędzy dwoma punktami danych na data, to zwraca wartość bliższego punktu
        = sample_at(<float> time) - zwraca liczbę naturalną i określającą która wartość w data odpowiada danemu czasowi
        = data_slice(<float> begin_time, <float> end_time, [<float> value_every, <int> value_count]) - zwraca tablicę fragmentu data który odpowiada danemu wycinkowi czasu. Opcjonalnie wartości w tablicy są podawane co jakiś odstęp czasu (value_every), lub zwrócona jest tylko określona liczba punktów (value_count)
        = replace_slice(<float> begin_time, <float> end_time, <Data_line> data_line) - zamienia fragment swojego wykresu innym, np. przefiltrowanym
        = generate_coordinate_tables([<float> begin_time, <float> end_time, <float> begin_x]) - zwraca dwie tablice; współrzędnych x oraz współrzędnych y punktów całości albo wycinka; begin_x oznacza od której wartości x mają się zaczynać współrzędne punktów
    Data_points - zestaw punktów
        > <string> point_type - rodzaj punktów ('sbp','r','dn',itp.)
        > <numpy.array> data_x - tablica (numpy array) zawierająca wszystkie wartości x punktów w kolejności czasowej
        > <numpy.array> data_y - tablica (numpy array) zawierająca wszystkie wartości y punktów w kolejności czasowej
        = slice_range(<float> begin_time, <float> end_time) - zwraca tuple indexów punktów w danym zakresie czasu
        = data_slice(<float> begin_time, <float> end_time) - zwraca dwie tablice; współrzędnych x oraz współrzędnych y punktów na danym odcinku czasowym
        = delete_slice(<float> begin_time, <float> end_time) - usuwa punkty z danego odcinka czasowego <begin_time; end_time>
        = replace_slice(<float> begin_time, <float> end_time, <Data_points> data_points) - zamienia fragment punktów innym, np. znalezionych innym algorytmem
        = add_point(<float> x, <float> y) - dodaje punkt do odpowiedniego miejsca w data_x i data_y
        = add_points(<Data_points> points) - dodaje punkty z danego Data_points do data_x i data_y
        = delete_point(<float> x, <float> y) - usuwa punkt o wspolrzędnych najbliższych do podanych
        = align_to_line(<Data_line> data_line) - zmienia wartość y punktów na wartość y danej linii w tym samym x; przydatne jeśli linia została przefiltrowana/edytowana
        = move_in_time(<float> time) - przesuwa wszystkie punkty o daną długość czasu
    Composite_data - zestaw linii oraz punktów wykresu; komplet danych, na którym mogą być przeprowadzane operacje; wszystkie dane na głównym ekranie są jednym wielkim Composite_data
        > <dict> data_lines - słownik (dictionary) wszystkich Data_line (wykresów liniowych) liniowych przechowywanych w Composite_data
        > <dict> data_points - słownik (dictionary) wszystkich Data_points (zestawów punktów) przechowywanych w Composite_data
        = calculate_time_range(<list of strings> required_lines) - zwraca dwie wartości float, które oznaczają początek i koniec przedziału czasowego na którym wszystkie żądane linie danych są obecne
        = add_data_line(<Data_line> data_line, [<string> dict_type, <boolean> replace]) - dodaje dany Data_line do data_lines oraz przelicza complete_length
        = delete_data_line(<string> dict_type) - usuwa data_lines[dict_type] i rekalkuluje complete_length
        = add_data_points(<Data_points> data_points, [<string> dict_type, <boolean> join]) - dodaje dany Data_points do swojego data_points; jeśli join == False, to w przypadku konfliktu zajętego już miejsca data_points[dict_type] dopisuje punkty do już obecnych
        = delete_data_points(<string> dict_type) - usuwa data_points[dict_type]
sigman/file_manager.py
    = save_composite_data(<string> file_name, <Composite_data> data) - zapisuje Composite_data do pliku file_name
    = open_composite_data(<string> file_name) - zwraca Composite_data zapisany w pliku file_name
    = import_dat(<string> file_name) - importuje dwie tablice (prawdopodobnie x i y) z pliku .dat; wykorzystywana przez pozostałe funkcje importujące
    = import_line_dat(<string> file_name, <string> line_type, [<float> offset]) - importuje Data_line z pliku .dat
    = import_point_dat(<string> file_name, <string> line_type) - importuje Data_points z pliku .dat
    = import_line(<string> file_name, <string> line_type, [<float> offset]) - importuje Data_line z danego pliku
    = import_points(<string> file_name, <string> line_type) - importuje Data_points z danego pliku
    = export_dat(<string> file_name) - exportuje dwie tablice do pliku .dat; wykorzystywana przez pozostałe funkcje eksportujące
    = explort_line_dat(<string> file_name, <Data_line> data_line) - eksportuje Data_line do pliku .dat
    = explort_point_dat(<string> file_name, <Data_points> data_points) - eksportuje Data_points do pliku .dat
sigman/analyzer.py
    = import_procedure_module(<string> name) - zwraca moduł procedury z folderu procedures
    = import_procedure(<string> name) - zwraca procedurę z folderu procedures oraz dictionary jej opcji
    = find_points(<Composite_data> composite_data, <float> begin_time, <float> end_time, <procedure> procedure, [<string> line_type]) - zwraca Data_points odnalezione na podstawie danej procedury na odcinku <begin_time; end_time>
    = filter_line(<Data_line> data_line ,<float> begin_time, <float> end_time, <procedure> procedure, [<string> line_type]) - zwraca Data_line odcinka <begin_time; end_time> przefiltrowane daną procedurą
sigman/visualizer.py
    > <dict> type_colors - dict kolorów odpowiadających typom danych
    = visualize_composite_data(<Composite_data> composite_data, [<float> begin_time, <float> end_time, <string> title, <list string> wanted_lines, <lista string> wanted_points]) - pokazuje proste okno matplotlib ze wszystkimi llub tylko z wymaganymi danymi
